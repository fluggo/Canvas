# Based on the fast-half conversion code by Jeroen van der Zijp
from __future__ import print_function

print('/* Auto-generated by genhalf.py */')
print('#include <stdint.h>')
print()
print('struct { uint16_t base; uint8_t shift; } f2h_baseshifttable[] = {')

for i in range(256):
    e = i - 127

    if e < -24:
        print('\t{ 0x0, 24 },')
    elif e < -14:
        print('\t{ ', hex(0x0400 >> (-14 - e)), ', ', str(-e - 1), ' },', sep='')
    elif e <= 15:
        print('\t{ ', hex((e + 15) << 10), ', 13 },', sep='')
    elif e < 128:
        print('\t{ 0x7C00, 24 },')
    else:
        print('\t{ 0x7C00, 13 },')

for i in range(256):
    e = i - 127

    if e < -24:
        print('\t{ 0x8000, 24 },')
    elif e < -14:
        print('\t{ ', hex((0x0400 >> (-14 - e)) | 0x8000), ', ', str(-e - 1), ' },', sep='')
    elif e <= 15:
        print('\t{ ', hex(((e + 15) << 10) | 0x8000), ', 13 },', sep='')
    elif e < 128:
        print('\t{ 0xFC00, 24 },')
    else:
        print('\t{ 0xFC00, 13 }')

print('};')
print()

print('uint32_t h2f_mantissatable[] = {')
print('\t0,')

for i in range(1,1024):
    m = i << 13
    e = 0

    while m & 0x00800000 == 0:
        e -= 0x00800000
        m <<= 1

    m &= ~0x00800000
    e += 0x38800000

    print('\t', hex(m | e), ',', sep='')

for i in range(1024):
    print('\t', hex(0x38000000 + (i << 13)), ',', sep='')

print('};')
print()

print('struct { uint16_t exponent, offset; } h2f_offsetexponenttable[] = {')

print('\t{ 0x0, 0 },')

for i in range(1,31):
    print('\t{ ', hex(i << 7), ', 1024 },', sep='')

print('\t{ 0x4780, 1024 },')
print('\t{ 0x8000, 0 },')

for i in range(1,31):
    print('\t{ ', hex(0x8000 | (i << 7)), ', 1024 },', sep='')

print('\t{ 0xC780, 1024 }')
print('};')

